/* =========================================
   資料結構題庫系統
   包含 CH1 ~ CH5 及 Final 的題庫
   邏輯：每次測驗從對應題庫隨機抽取 10 題
   ========================================= */
// ... 其他變數 ...
const questionBank = {
    // === 第一章：演算法與指標 (請擴充至30題) ===
   // === 第一章：演算法與指標 (共 60 題) ===
    ch1: [
        // --- 演算法與 Big O 基礎 ---
        { q: "演算法 (Algorithm) 的核心定義是什麼？", o: ["程式語言的語法", "解決問題的方法與步驟", "電腦的硬體架構", "資料庫的設計"], a: 1, h: "演算法是解決特定問題的執行步驟 。" },
        { q: "在 Big O 表示法中，若 f(n) = 100n + 9，其時間複雜度為？", o: ["O(1)", "O(n)", "O(n^2)", "O(log n)"], a: 1, h: "保留最高次項 n，忽略係數 100 與常數 9 。" },
        { q: "下列哪一個時間複雜度成長速度最快（效率最差）？", o: ["O(n)", "O(n log n)", "O(n^2)", "O(2^n)"], a: 3, h: "指數成長 (2^n) 比多項式成長更快 。" },
        { q: "下列哪一個時間複雜度成長速度最慢（效率最好）？", o: ["O(1)", "O(log n)", "O(n)", "O(n^2)"], a: 0, h: "常數時間 O(1) 是最理想的 。" },
        { q: "計算時間複雜度時，主要關注的是？", o: ["最佳情況", "平均情況", "最壞情況 (Upper Bound)", "執行秒數"], a: 2, h: "Big O 代表演算法執行的上界 (Upper Bound) 。" },
        { q: "若 f(n) = 3n^3 + 20n^2 + 5，其 Big O 為？", o: ["O(n^2)", "O(n^3)", "O(n)", "O(1)"], a: 1, h: "取最高次方 n^3 。" },
        { q: "若程式中有雙層巢狀迴圈 (Nested Loops)，且皆執行 n 次，其複雜度通常為？", o: ["O(n)", "O(log n)", "O(n^2)", "O(2^n)"], a: 2, h: "n * n = n^2 。" },
        { q: "O(n log n) 的成長速率介於哪兩者之間？", o: ["O(1) 與 O(n)", "O(n) 與 O(n^2)", "O(n^2) 與 O(n^3)", "O(n^3) 與 O(2^n)"], a: 1, h: "n < n log n < n^2 。" },
        { q: "Omega (Ω) 符號代表的是？", o: ["上界 (Upper Bound)", "下界 (Lower Bound)", "平均情況", "空間複雜度"], a: 1, h: "Big Omega 代表下界 。" },
        { q: "Theta (θ) 符號代表的是？", o: ["上界", "下界", "平均/緊密邊界 (Average/Tight Bound)", "最壞情況"], a: 2, h: "Theta 代表平均或緊密邊界 。" },
        
        // --- 迴圈次數計算 (參考 S__8839172_0.pdf) ---
        { q: "程式片段 for(i=1; i<=100; i+=2) x++; 執行次數為？", o: ["100", "50", "51", "49"], a: 1, h: "i=1, 3, 5...99，共 50 次 。" },
        { q: "程式片段 for(i=1; i<=n; i++) x++; 的時間複雜度為？", o: ["O(1)", "O(n)", "O(n^2)", "O(log n)"], a: 1, h: "迴圈執行 n 次，故為 O(n) 。" },
        { q: "程式片段 for(i=1; i<=n; i++) for(j=1; j<=n; j++) x++; 的複雜度為？", o: ["O(n)", "O(n^2)", "O(n log n)", "O(1)"], a: 1, h: "雙層迴圈 n*n 。" },
        { q: "程式片段 int i=1; while(i<=n) { i=i*2; } 的複雜度為？", o: ["O(n)", "O(n^2)", "O(log n)", "O(1)"], a: 2, h: "每次 i 乘以 2，執行次數為 log2(n) 。" },
        { q: "若 f(n) = 10，其 Big O 為？", o: ["O(1)", "O(n)", "O(10)", "O(0)"], a: 0, h: "常數函數的複雜度為 O(1) 。" },
        { q: "計算 1+2+...+n 的演算法，若用公式 n(n+1)/2 計算，複雜度為？", o: ["O(n)", "O(n^2)", "O(1)", "O(log n)"], a: 2, h: "只執行一次運算，與 n 大小無關，故為 O(1)。" },
        { q: "下列何者成長速率比 O(n^3) 還快？", o: ["O(n^2)", "O(n log n)", "O(2^n)", "O(n)"], a: 2, h: "指數成長 2^n 大於多項式 n^3 。" },
        { q: "在 Big O 分析中，係數 (Coefficients) 應該如何處理？", o: ["保留", "忽略", "平方", "開根號"], a: 1, h: "如 2n 視為 n，係數忽略不計 。" },
        { q: "若 f(n) = 5 * 2^n + 9n^2，其 Big O 為？", o: ["O(n^2)", "O(2^n)", "O(n)", "O(1)"], a: 1, h: "指數項 2^n 成長最快，故主導複雜度 。" },
        { q: "矩陣相乘 (n x n) 的標準演算法時間複雜度通常為？", o: ["O(n)", "O(n^2)", "O(n^3)", "O(log n)"], a: 2, h: "三層迴圈：i, j, k 各跑 n 次 。" },

        // --- 指標基礎觀念 ---
        { q: "在 C 語言中，哪一個符號用於「取址 (Address-of)」？", o: ["*", "&", "#", "@"], a: 1, h: "& 用來取得變數的記憶體位址 。" },
        { q: "在 C 語言中，哪一個符號用於宣告指標或「取值 (Dereference)」？", o: ["&", "^", "*", "$"], a: 2, h: "* 用於宣告 int *p 或取值 *p 。" },
        { q: "若 int a = 10; int *p = &a; 請問 *p 代表什麼？", o: ["a 的位址", "p 的位址", "a 的值 (10)", "undefined"], a: 2, h: "*p 代表前往 p 指向的地址取值 。" },
        { q: "指標變數 (Pointer Variable) 主要用來儲存什麼？", o: ["整數值", "浮點數", "記憶體位址", "字元"], a: 2, h: "指標專門用來存放地址 。" },
        { q: "若要列印指標變數的地址，printf 應使用哪個格式？", o: ["%d", "%c", "%f", "%p"], a: 3, h: "%p 是 pointer 的格式符號 。" },
        { q: "在 32 位元系統中，一個指標通常佔用多少記憶體？", o: ["1 byte", "2 bytes", "4 bytes", "8 bytes"], a: 2, h: "32位元系統通常為 4 bytes (64位元為 8 bytes)。" },
        { q: "宣告 int *p; 代表 p 指向的資料型態是？", o: ["char", "float", "int", "double"], a: 2, h: "int *p 代表 p 儲存的是 int 變數的地址 。" },
        { q: "若 p 是指標，p++ 的意思是？", o: ["p 的值加 1", "p 指向的位址值加 1", "p 移動到下一個記憶體單元", "語法錯誤"], a: 2, h: "指標運算會根據型態大小移動 。" },
        { q: "請問 &(*p) 的結果等同於？", o: ["p", "*p", "&p", "1"], a: 0, h: "取值後再取址，抵銷回到原本的指標 p。" },
        { q: "若 int a=5, *p=&a; 執行 *p = 10 後，a 的值為何？", o: ["5", "10", "0", "錯誤"], a: 1, h: "透過指標修改了 a 的記憶體內容 。" },

        // --- 進階指標與 Call by ... ---
        { q: "int **p 代表什麼？", o: ["指向整數的指標", "指向指標的指標 (雙重指標)", "兩個整數", "語法錯誤"], a: 1, h: "雙星號代表 Pointer to Pointer 。" },
        { q: "若 int a=10; int *p=&a; int **pp=&p; 請問 **pp 的值是？", o: ["p 的地址", "a 的地址", "a 的值 (10)", "undefined"], a: 2, h: "兩次 Dereference：pp -> p -> a 。" },
        { q: "C 語言中，若函式參數為 int a (非指標)，這是哪種傳遞方式？", o: ["Call by Value", "Call by Address", "Call by Name", "Call by Reference"], a: 0, h: "只傳遞數值複製，不會影響原變數 。" },
        { q: "若要在函式內修改主程式的變數，參數應宣告為？", o: ["int a", "int *a", "float a", "const int a"], a: 1, h: "必須傳遞位址 (指標) 才能修改原變數 。" },
        { q: "在宣告 int *p = &a; 中，* 號的作用是？", o: ["乘法運算", "取值運算", "宣告型態", "取址運算"], a: 2, h: "此處的 * 是宣告 p 為指標型態 。" },
        { q: "若 ptr 是一個指標，&ptr 代表？", o: ["ptr 指向的值", "ptr 指向的位址", "ptr 變數本身的位址", "NULL"], a: 2, h: "指標變數本身也有自己的記憶體位址 。" },
        { q: "下列哪個譬喻最適合形容「指標」？", o: ["房子", "住戶", "地址紀錄簿", "家具"], a: 2, h: "指標紀錄別人的地址 。" },
        { q: "若 int *p = NULL; 代表？", o: ["p 指向記憶體位置 0", "p 指向整數 0", "p 不指向任何有效位址", "語法錯誤"], a: 2, h: "NULL 代表空指標，未指向任何物件。" },
        { q: "在 C 語言中，陣列名稱 (Array Name) 可以視為？", o: ["變數", "常數指標 (指向第一個元素)", "整數", "字串"], a: 1, h: "陣列名稱代表第 0 個元素的位址。" },
        { q: "若 int a[5]; 則 a 與 &a[0] 的關係是？", o: ["數值相等", "位址相等", "完全不同", "型態相同"], a: 1, h: "陣列名即為首元素位址。" },

        // --- 綜合與程式追蹤 (參考 S__8839172_0.pdf) ---
        { q: "執行 for(i=0; i<100; i+=5) x++; [cite_start]迴圈會執行幾次？", o: ["100", "50", "20", "25"], a: 2, h: "100 / 5 = 20 次 。" },
        { q: "Big O 是為了估算程式的？", o: ["執行精確時間", "程式碼行數", "執行效率隨輸入增加的變化趨勢", "記憶體佔用量"], a: 2, h: "Big O 描述成長速率 。" },
        { q: "下列何者是「線性時間」複雜度？", o: ["O(1)", "O(n)", "O(n^2)", "O(log n)"], a: 1, h: "O(n) 圖形為直線，稱為線性時間。" },
        { q: "int *p; *p = 100; 這段程式碼有什麼潛在問題？", o: ["沒有問題", "p 未初始化，可能導致崩潰", "型態不符", "語法錯誤"], a: 1, h: "p 是野指標，直接寫入會導致錯誤。" },
        { q: "若要交換兩個變數 x, y，函式 swap 應如何呼叫？", o: "swap(x, y)", o: ["swap(x, y)", "swap(&x, &y)", "swap(*x, *y)", "swap(x&, y&)"], a: 1, h: "需傳入地址才能交換 。" },
        { q: "int final_grades = 59; int *p = &final_grades; *p = 60; [cite_start]執行後 final_grades 為？", o: ["59", "60", "0", "錯誤"], a: 1, h: "透過指標修改了變數值 。" },
        { q: "指標的指標 (Double Pointer) 常見用途為何？", o: ["修改整數", "修改指標的指向", "節省空間", "加快運算"], a: 1, h: "用來改變「指標變數」裡面存的地址。" },
        { q: "若 f(n) = 3 * 2^n + 100n^5，Big O 為？", o: ["O(n^5)", "O(2^n)", "O(n)", "O(1)"], a: 1, h: "指數成長 (2^n) 遠大於多項式 (n^5) 。" },
        { q: "對於已經排序好的陣列，二元搜尋 (Binary Search) 的複雜度為？", o: ["O(n)", "O(1)", "O(log n)", "O(n^2)"], a: 2, h: "每次切一半，故為 log n。" },
        { q: "泡沫排序 (Bubble Sort) 的平均時間複雜度為？", o: ["O(n)", "O(n log n)", "O(n^2)", "O(1)"], a: 2, h: "雙層迴圈交換，為 O(n^2)。" },
        { q: "在 Pointer Arithmetic 中，p+1 實際增加的位址量取決於？", o: ["1 byte", "4 bytes", "p 指向的資料型態大小", "CPU 速度"], a: 2, h: "若指向 int 則 +4，char 則 +1。" },
        { q: "void func(int *p) { p = NULL; } 執行後，主程式的指標會變 NULL 嗎？", o: ["會", "不會", "不一定", "編譯錯誤"], a: 1, h: "因為 p 是傳值 (指標的複本)，修改 p 本身不影響外部。" },
        { q: "void func(int **p) { *p = NULL; } 執行後，主程式的指標會變 NULL 嗎？", o: ["會", "不會", "不一定", "編譯錯誤"], a: 0, h: "傳入了指標的地址，故可以修改指標的指向。" },
        { q: "Big O 符號忽略了多項式的？", o: ["最高次項", "低次項與係數", "變數", "指數"], a: 1, h: "只保留最高次項，忽略係數 [cite: 3481]。" },
        { q: "O(1) 的意思是什麼？", o: ["程式執行 1 秒", "程式執行 1 次", "執行時間與輸入大小無關", "執行時間線性成長"], a: 2, h: "Constant Time (常數時間)。" },
        { q: "int *p; printf('%d', sizeof(p)); 在 64 位元系統輸出為？", o: ["4", "8", "2", "16"], a: 1, h: "64位元系統指標佔 8 bytes。" },
        { q: "什麼情況下 O(n^2) 演算法比 O(n) 快？", o: ["n 很大時", "n 很小時", "永遠不會", "n 為負數時"], a: 1, h: "當 n 很小時，係數影響較大，但 Big O 關注 n 很大時的情況。" },
        { q: "遞迴函式 (Recursive Function) 的空間複雜度主要來自？", o: ["全域變數", "堆疊 (Stack) 深度", "迴圈次數", "硬碟空間"], a: 1, h: "遞迴會佔用 Stack Frame。" },
        { q: "若 int a[10]; *(a+3) 等同於？", o: ["a[3]", "&a[3]", "a[2]", "a[4]"], a: 0, h: "指標運算寫法 *(a+i) 等同於 a[i]。" },
        { q: "下列何者是正確的指標宣告與初始化？", o: ["int *p = 10;", "int *p = &a;", "int p = &a;", "*p = &a;"], a: 1, h: "int *p 宣告指標，&a 取址賦值 。" }333
    ],

    // === 第二章：陣列 (請擴充至30題) ===
    // === 第二章：陣列 (Arrays) (共 60 題) ===
    ch2: [
        // --- 1. 基礎概念 ---
        { q: "在 C 語言中，陣列在記憶體中的配置方式是？", o: ["連續配置", "鏈結配置", "隨機配置", "雜湊配置"], a: 0, h: "陣列佔用一塊連續的記憶體空間。" },
        { q: "存取陣列中任意一個元素的時間複雜度為何？", o: ["O(1)", "O(n)", "O(log n)", "O(n^2)"], a: 0, h: "陣列支援隨機存取 (Random Access)。" },
        { q: "若 int A[10]; 起始位址為 100，每個 int 佔 4 bytes，則 A[3] 的位址為？", o: ["112", "103", "116", "104"], a: 0, h: "100 + 3 * 4 = 112。" },
        { q: "二維陣列 A[m][n] 中，m 代表什麼？", o: ["列數 (Rows)", "行數 (Columns)", "總元素數", "維度"], a: 0, h: "通常第一個維度代表列 (Row)。" },
        { q: "下列何者不是陣列的缺點？", o: ["存取速度慢", "插入刪除困難", "大小固定", "記憶體空間需連續"], a: 0, h: "存取速度快是陣列的優點。" },
        { q: "C 語言與 C++ 預設使用哪種陣列排列方式？", o: ["Row Major (以列為主)", "Column Major (以行為主)", "Zigzag", "Random"], a: 0, h: "C 家族語言皆為 Row Major。" },
        { q: "Fortran 語言通常使用哪種陣列排列方式？", o: ["Column Major", "Row Major", "Stack Major", "Queue Major"], a: 0, h: "Fortran 是少數使用 Column Major 的語言。" },
        { q: "若陣列 A[-2...2] 共有幾個元素？", o: ["5", "4", "6", "3"], a: 0, h: "2 - (-2) + 1 = 5。" },
        { q: "陣列名稱在 C 語言中代表什麼？", o: ["第一個元素的位址", "陣列的大小", "陣列的值", "最後一個元素的位址"], a: 0, h: "Array Name = &A[0]。" },
        { q: "在 Row Major 排列中，二維陣列最右邊的維度 (Column) 變化速度？", o: ["最快", "最慢", "不一定", "與 Row 一樣"], a: 0, h: "記憶體中相鄰元素是同列不同行，故行索引變化最快。" },

        // --- 2. 一維與二維陣列計算 (Row Major) ---
        { q: "陣列 A[1...10] 起始位址 200，size=2，求 A[5] 位址？", o: ["208", "210", "205", "212"], a: 0, h: "200 + (5-1)*2 = 208。" },
        { q: "陣列 A[0...5, 0...5] (Row Major)，起始 100，size=1，求 A[2][3]？", o: ["115", "112", "123", "105"], a: 0, h: "100 + (2*6 + 3)*1 = 115 (注意行數是6)。" },
        { q: "陣列 A[1...5, 1...4] (Row Major)，起始 1000，size=4，求 A[3][2]？", o: ["1040", "1024", "1032", "1016"], a: 0, h: "1000 + [(3-1)*4 + (2-1)]*4 = 1000 + 10*4 = 1040。" },
        { q: "陣列 A[-2...2, -2...2] (Row Major)，起始 0，size=1，求 A[0][0]？", o: ["12", "10", "13", "0"], a: 0, h: "列寬5。0 + [(0 - (-2))*5 + (0 - (-2))]*1 = (2*5 + 2) = 12。" },
        { q: "陣列 A[10][10] (Row Major)，起始 500，size=2，求 A[5][5]？", o: ["610", "555", "600", "550"], a: 0, h: "500 + (5*10 + 5)*2 = 500 + 110 = 610。" },
        { q: "陣列 A[3...8, 2...6] (Row Major)，起始 200，size=1，求 A[5][4]？", o: ["212", "214", "210", "208"], a: 0, h: "行數(6-2+1)=5。200 + [(5-3)*5 + (4-2)] = 200 + 12 = 212。" },
        { q: "陣列 M[4][3] (Row Major)，起始 100，size=1，M[2][1] 位址為？", o: ["107", "105", "108", "106"], a: 0, h: "100 + (2*3 + 1) = 107。" },
        { q: "陣列 B[1...m, 1...n] (Row Major)，B[i][j] 的位址公式為？", o: "Base + ((i-1)n + (j-1)) * size", o: ["Base + ((i-1)n + (j-1))*size", "Base + ((j-1)m + (i-1))*size", "Base + (i*n + j)*size", "Base + (j*m + i)*size"], a: 0, h: "Row Major 先算過幾列，再加行。" },
        { q: "若 A[0...4, 0...3] (Row Major) A[2][2] 位址為 220，size=2，求起始位址？", o: ["200", "210", "204", "198"], a: 0, h: "Offset = (2*4 + 2)*2 = 20。Base = 220 - 20 = 200。" },
        { q: "陣列 A[6][8] (Row Major)，A[3][3] 的位址與下列何者相同 (Column Major)？", o: "假設維度相同", o: ["A[?][?] 難以直接比較", "A[3][3]", "A[4][4]", "需計算"], a: 3, h: "不同排列方式的偏移量不同，需計算。" },

        // --- 3. 二維陣列計算 (Column Major) ---
        { q: "陣列 A[0...5, 0...5] (Column Major)，起始 100，size=1，求 A[2][3]？", o: ["120", "115", "112", "123"], a: 0, h: "100 + (3*6 + 2)*1 = 120 (列數=6)。" },
        { q: "陣列 A[1...5, 1...4] (Column Major)，起始 1000，size=4，求 A[3][2]？", o: ["1032", "1040", "1024", "1016"], a: 0, h: "1000 + [(2-1)*5 + (3-1)]*4 = 1000 + 7*4 = 1028 (更正選項: 1028)。Wait, let's calc: (2-1)*5 + (3-1) = 5+2=7. 7*4=28. Base 1000. Ans 1028. Option needs fix or select closest? Let's fix calculation. Col Major: (j-1)*Rows + (i-1). Rows=5. (2-1)*5 + (3-1) = 5+2=7. 1000+28=1028. 選項無1028，重算：Rows=5 (1..5). Cols=4. i=3, j=2. Offset = (j-L2)*Rows + (i-L1) = (2-1)*5 + (3-1) = 7. Addr = 1000 + 28 = 1028. (題目設計誤差，選接近或修正題目) -> 讓我們修正選項為 1028.", o: ["1028", "1040", "1024", "1032"], a: 0 },
        { q: "陣列 M[4][3] (Column Major)，起始 100，size=1，M[2][1] 位址為？", o: ["106", "107", "105", "108"], a: 0, h: "Rows=4. 100 + (1*4 + 2) = 106。" },
        { q: "陣列 A[-2...2, -2...2] (Column Major)，起始 0，size=1，求 A[0][0]？", o: ["12", "10", "13", "0"], a: 0, h: "Rows=5. 0 + [(0 - (-2))*5 + (0 - (-2))]*1 = 12 (對稱矩陣Row/Col相同)。" },
        { q: "陣列 B[1...m, 1...n] (Column Major)，B[i][j] 的位址公式為？", o: ["Base + ((j-1)m + (i-1))*size", "Base + ((i-1)n + (j-1))*size", "Base + (j*n + i)*size", "Base + (i*m + j)*size"], a: 0, h: "Column Major 先算過幾行，再加列。" },
        { q: "若 A[5][10] (Col Major)，起始 0，size=1，求 A[3][4]？", o: ["23", "34", "43", "24"], a: 0, h: "Rows=5. 0 + (4*5 + 3) = 23。" },
        { q: "陣列 A[2...5, 1...4] (Col Major)，起始 200，size=2，求 A[4][3]？", o: ["220", "210", "215", "222"], a: 0, h: "Rows=4 (2,3,4,5). Cols=4. i=4, j=3. Offset = (3-1)*4 + (4-2) = 8+2=10. Addr = 200 + 10*2 = 220。" },
        { q: "Row Major 和 Column Major 對 A[0][0] 的位址計算結果？", o: ["相同", "不同", "視 m, n 而定", "視 size 而定"], a: 0, h: "起始點永遠相同。" },
        { q: "在 Fortran (Column Major) 中，A[10][20] 的 A[1][2] 與 A[2][2] 記憶體距離？", o: ["1個元素", "20個元素", "10個元素", "2個元素"], a: 0, h: "Column Major 中，同 Column 相鄰 Row 的元素是連續的。" },
        { q: "在 C (Row Major) 中，A[10][20] 的 A[1][2] 與 A[2][2] 記憶體距離？", o: ["20個元素", "1個元素", "10個元素", "2個元素"], a: 0, h: "Row Major 中，跨一列需跳過整個 Row 的長度 (20)。" },

        // --- 4. 三維與多維陣列計算 ---
        { q: "三維陣列 A[2][3][4] (Row Major)，求 A[1][1][1] 的偏移量？", o: ["17", "16", "15", "18"], a: 0, h: "1*(3*4) + 1*4 + 1 = 12 + 4 + 1 = 17。" },
        { q: "三維陣列 A[2][3][4] (Column Major)，求 A[1][1][1] 的偏移量？", o: ["9", "10", "11", "12"], a: 0, h: "1*(2*3) + 1*2 + 1 = 6 + 2 + 1 = 9。" },
        { q: "若 A[u1][u2][u3] 為 Row Major，計算 A[i][j][k] 時，k 的係數為？", o: ["1", "u2", "u3", "u2*u3"], a: 0, h: "Row Major 最後一個維度是連續的，係數為 1 (或 d)。" },
        { q: "若 A[u1][u2][u3] 為 Col Major，計算 A[i][j][k] 時，i 的係數為？", o: ["1", "u1", "u2", "u1*u2"], a: 0, h: "Col Major 第一個維度是連續的，係數為 1 (或 d)。" },
        { q: "陣列 A[1...3, 1...2, 1...4] (Row Major)，起始 100，size=1，求 A[2][1][3]？", o: ["110", "111", "112", "109"], a: 0, h: "Dims: 3, 2, 4. Offset: (2-1)*2*4 + (1-1)*4 + (3-1) = 8 + 0 + 2 = 10. Addr: 110。" },
        { q: "計算 N 維陣列位址時，最重要的參數是？", o: ["各維度的大小與排列順序", "陣列名稱", "編譯器種類", "作業系統"], a: 0, h: "維度大小決定了跳躍的幅度。" },
        { q: "三維陣列可以想像成？", o: ["一本書 (頁、行、列)", "一條線", "一張表", "一個點"], a: 0, h: "3D = Pages * Rows * Cols。" },
        { q: "陣列 A[5][5][5] 總共有多少元素？", o: ["125", "15", "25", "50"], a: 0, h: "5 * 5 * 5 = 125。" },
        { q: "在 Row Major 中，A[i][j][k] 的下一個連續記憶體元素是？", o: ["A[i][j][k+1]", "A[i][j+1][k]", "A[i+1][j][k]", "A[i][j][k-1]"], a: 0, h: "最後一個索引變動最快。" },
        { q: "在 Col Major 中，A[i][j][k] 的下一個連續記憶體元素是？", o: ["A[i+1][j][k]", "A[i][j+1][k]", "A[i][j][k+1]", "A[i-1][j][k]"], a: 0, h: "第一個索引變動最快。" },

        // --- 5. 特殊矩陣 (三角形、稀疏) ---
        { q: "下三角形矩陣 (Lower Triangular Matrix) 的非零元素位於？", o: ["主對角線及其下方", "主對角線及其上方", "僅在主對角線", "隨機分佈"], a: 0, h: "i >= j 的區域。" },
        { q: "上三角形矩陣 (Upper Triangular Matrix) 的非零元素條件為？", o: ["i <= j", "i >= j", "i = j", "i != j"], a: 0, h: "Row index 小於等於 Col index。" },
        { q: "將 n x n 下三角形矩陣壓縮至 1D 陣列，需要的大小為？", o: ["n(n+1)/2", "n^2", "n", "n(n-1)/2"], a: 0, h: "等差級數 1+2+...+n。" },
        { q: "對於下三角形矩陣 A[5][5]，A[3][1] (0-indexed) 映射到 1D 陣列的索引 k (Row Major) 為？", o: ["7", "6", "8", "9"], a: 0, h: "k = 3*(3+1)/2 + 1 = 6 + 1 = 7。Wait, formula: i(i+1)/2 + j (if 0-indexed and include diagonal). Row 0:1, Row 1:2, Row 2:3. Before row 3: 1+2+3=6 elements. Plus index 1 = 7. Correct." },
        { q: "對於上三角形矩陣 A[5][5]，A[0][4] (0-indexed) 映射到 1D 陣列的索引 k (Row Major) 為？", o: ["4", "5", "3", "0"], a: 0, h: "Row 0 starts at 0. j=4. k = 0 + 4 = 4。" },
        { q: "稀疏矩陣 (Sparse Matrix) 是指？", o: ["大部分元素為 0 的矩陣", "大部分元素不為 0", "對角線為 1", "只有 0 和 1"], a: 0, h: "非零元素很少。" },
        { q: "稀疏矩陣通常使用什麼資料結構來節省空間？", o: ["三元組 (3-tuple) 陣列或鏈結串列", "二維陣列", "堆疊", "佇列"], a: 0, h: "只存 (row, col, value)。" },
        { q: "對稱矩陣 (Symmetric Matrix) 的特性是？", o: ["A[i][j] = A[j][i]", "A[i][j] = -A[j][i]", "A[i][j] = 0", "A[i][j] = 1"], a: 0, h: "沿主對角線對稱。" },
        { q: "對稱矩陣可以只儲存什麼來節省空間？", o: ["下三角形或上三角形", "對角線", "第一列", "最後一列"], a: 0, h: "因為另一半是重複的。" },
        { q: "三對角矩陣 (Tridiagonal Matrix) 的非零元素位於？", o: ["主對角線及相鄰的兩條對角線", "只有主對角線", "四週邊界", "正中間"], a: 0, h: "|i-j| <= 1。" },
        { q: "將 A[n][n] 壓縮為 1D 陣列後，存取時間複雜度變為？", o: ["O(1)", "O(n)", "O(log n)", "O(n^2)"], a: 0, h: "仍然是透過公式計算，視為常數時間。" },
        { q: "下三角形矩陣 A[4][4]，總共有幾個非零元素？", o: ["10", "16", "8", "12"], a: 0, h: "4*(5)/2 = 10。" },
        { q: "若 A[i][j] 在 i < j 時為 0，則 A 是？", o: ["下三角形矩陣", "上三角形矩陣", "對角矩陣", "稀疏矩陣"], a: 0, h: "非零元素在 i >= j (下三角)。" },
        { q: "C 語言中實作多項式加法，若使用陣列 index 代表指數，適合哪種多項式？", o: ["稠密多項式 (Dense)", "稀疏多項式 (Sparse)", "所有多項式", "單項式"], a: 0, h: "若是稀疏 (如 x^1000 + 1)，會浪費大量 0 的空間。" },
        { q: "稀疏多項式 (如 3x^100 + 5x) 適合用什麼表示？", o: ["結構陣列 {(coef, exp)}", "純係數陣列", "二維陣列", "字串"], a: 0, h: "只存非零項的係數與指數。" },

        // --- 6. 多項式與綜合題 ---
        { q: "使用陣列表示多項式 P(x) = 5x^3 + 2x + 1，陣列內容可能為？(由低次到高次)", o: ["1, 2, 0, 5", "5, 2, 1, 0", "1, 2, 5", "5, 0, 2, 1"], a: 0, h: "x^0=1, x^1=2, x^2=0, x^3=5。" },
        { q: "兩個 n 次多項式相加，時間複雜度為？", o: ["O(n)", "O(n^2)", "O(1)", "O(log n)"], a: 0, h: "只需遍歷一次係數。" },
        { q: "若多項式用結構陣列儲存 (coef, exp)，相加時需注意？", o: ["指數相同的項係數相加", "係數相同的項指數相加", "直接串接", "相乘"], a: 0, h: "同類項合併。" },
        { q: "魔術方陣 (Magic Square) 的特性是？", o: ["行、列、對角線和相等", "所有元素為 0", "對稱矩陣", "上三角矩陣"], a: 0, h: "這是定義。" },
        { q: "奇數階魔術方陣的填寫口訣，第一個數字 1 放在？", o: ["第一列中間", "正中央", "左上角", "右下角"], a: 0, h: "Start at top middle。" }
    ],

    // === 第三章：堆疊/佇列/鏈結 (請擴充至30題) ===
   // === 第三章：堆疊、佇列與鏈結串列 (共 60 題) ===
    ch3: [
        // --- 1. 鏈結串列 (Linked List) 基礎與操作 (Q1-Q15) ---
        { q: "鏈結串列 (Linked List) 的基本組成單位稱為？", o: ["元素 (Element)", "節點 (Node)", "區塊 (Block)", "欄位 (Field)"], a: 1, h: "由資料與指標組成的 Node。" },
        { q: "在單向鏈結串列中，最後一個節點的指標 (Next) 通常指向？", o: ["Head", "Front", "NULL", "隨機位址"], a: 2, h: "NULL 代表串列結束。" },
        { q: "若要在單向鏈結串列的「最前端」插入一個新節點 x，正確順序是？", o: ["head = x; x->next = head;", "x->next = head; head = x;", "x->next = NULL; head = x;", "head->next = x;"], a: 1, h: "先讓新節點指嚮舊頭，再更新頭指標。" },
        { q: "在單向鏈結串列中，若只知道 Head，要刪除「最後一個節點」的時間複雜度為？", o: ["O(1)", "O(n)", "O(log n)", "O(n^2)"], a: 1, h: "必須從頭走訪到倒數第二個節點，故為 O(n)。" },
        { q: "雙向鏈結串列 (Doubly Linked List) 的節點包含幾個指標？", o: ["1 個 (Next)", "2 個 (Left, Right)", "3 個", "不一定"], a: 1, h: "LLINK (前) 與 RLINK (後)。" },
        { q: "在雙向鏈結串列中插入一個節點，通常需要調整幾個指標連結？", o: ["1", "2", "3", "4"], a: 3, h: "新節點的左右 2 條 + 前後鄰居指過來的 2 條 [cite: 1252-1255]。" },
        { q: "反轉 (Invert) 單向鏈結串列時，通常需要幾個輔助指標？", o: ["1", "2", "3", "4"], a: 2, h: "prev, current, p (或 next) 三個指標配合滑動。" },
        { q: "若 struct node { int data; struct node *next; }; 且 p 指向一個節點，p->next 代表？", o: ["p 的資料", "p 本身的位址", "下一個節點的位址", "下一個節點的資料"], a: 2, h: "指標指向下一個節點。" },
        { q: "環狀鏈結串列 (Circular Linked List) 的最後一個節點指向哪裡？", o: ["NULL", "Head (第一個節點)", "自己", "隨機"], a: 1, h: "形成一個環，指回頭部。" },
        { q: "若要串接 (Concatenate) 兩個單向鏈結串列，必須由第一個串列的哪裡開始找？", o: ["Head", "中間", "尾端 (Tail)", "任意點"], a: 2, h: "要找到尾端才能接上第二個串列的頭。" },
        { q: "在 C 語言中，動態配置一個節點記憶體的函式是？", o: ["alloc()", "malloc()", "new()", "create()"], a: 1, h: "memory allocation。" },
        { q: "釋放鏈結串列節點記憶體的函式是？", o: ["delete()", "remove()", "free()", "drop()"], a: 2, h: "C 語言使用 free()。" },
        { q: "與陣列相比，鏈結串列的主要缺點是？", o: ["插入刪除慢", "無法動態大小", "不支援隨機存取 (Random Access)", "浪費所有記憶體"], a: 2, h: "無法像陣列用 A[i] 直接跳到第 i 個元素，必須循序走訪。" },
        { q: "若 head 指標為 NULL，代表鏈結串列是？", o: ["滿的", "空的", "毀損的", "只有一個節點"], a: 1, h: "空串列。" },
        { q: "在雙向串列中刪除節點 x，下列哪個操作是必要的？", o: ["x->llink->rlink = x->rlink", "x->rlink = NULL", "x->llink = NULL", "head = NULL"], a: 0, h: "讓 x 的前一個節點，跨過 x 指向 x 的下一個。" },

        // --- 2. 堆疊 (Stack) 原理與實作 (Q16-Q30) ---
        { q: "堆疊 (Stack) 的存取特性是？", o: ["FIFO (先進先出)", "LIFO (後進先出)", "LILO (後進後出)", "隨機存取"], a: 1, h: "Last In, First Out。" },
        { q: "將資料放入堆疊的操作稱為？", o: ["Pop", "Push", "Enqueue", "Dequeue"], a: 1, h: "推入 (Push)。" },
        { q: "從堆疊取出資料的操作稱為？", o: ["Pop", "Push", "Top", "Bottom"], a: 0, h: "彈出 (Pop)。" },
        { q: "若使用陣列實作堆疊，top = -1 代表？", o: ["堆疊已滿", "堆疊是空的", "有一個元素", "錯誤狀態"], a: 1, h: "陣列索引從 0 開始，-1 代表無資料。" },
        { q: "若堆疊大小為 MAX_SIZE，判斷堆疊已滿 (IsFull) 的條件是？(top 從 -1 開始)", o: ["top == 0", "top == MAX_SIZE", "top == MAX_SIZE - 1", "top == NULL"], a: 2, h: "因為索引從 0 到 MAX-1。" },
        { q: "使用單向鏈結串列實作堆疊，最適合進行 Push/Pop 的位置是？", o: ["串列尾端 (Tail)", "串列前端 (Head)", "隨機位置", "中間位置"], a: 1, h: "前端操作是 O(1)，尾端需要 O(n) 走訪。" },
        { q: "若依序執行 Push(A), Push(B), Pop(), Push(C), Pop()，最後堆疊內剩下？", o: ["A", "B", "C", "A, B"], a: 0, h: "Push A -> [A]; Push B -> [A, B]; Pop -> [A]; Push C -> [A, C]; Pop -> [A]。" },
        { q: "在 Linked List Stack 中，Push 操作若 malloc 回傳 NULL 代表？", o: ["堆疊已滿 (記憶體不足)", "堆疊是空的", "操作成功", "節點錯誤"], a: 0, h: "無法配置記憶體即為 Stack Overflow。" },
        { q: "Stack Overflow 是指？", o: ["堆疊空的卻執行 Pop", "堆疊滿的卻執行 Push", "堆疊被刪除", "堆疊指標遺失"], a: 1, h: "溢位：滿了還塞。" },
        { q: "Stack Underflow 是指？", o: ["堆疊空的卻執行 Pop", "堆疊滿的卻執行 Push", "堆疊未初始化", "記憶體洩漏"], a: 0, h: "下溢：空了還拿。" },
        { q: "在 C 語言實作 Linked List Push 時，為何需要傳入 struct node **top (雙重指標)？", o: ["為了節省空間", "為了修改主程式中的 top 指標", "為了讀取資料", "C 語言規定"], a: 1, h: "Call by address 才能修改外部變數。" },
        { q: "若使用陣列實作 Stack，Pop 操作後通常如何調整 top？", o: ["top++", "top--", "top = 0", "不需調整"], a: 1, h: "指標往下移。" },
        { q: "遞迴函式 (Recursive Function) 執行時，系統會使用哪種資料結構來儲存狀態？", o: ["Queue", "Tree", "Stack", "Graph"], a: 2, h: "System Stack 用於儲存返回位址與區域變數 。" },
        { q: "下列哪種應用最適合使用 Stack？", o: ["印表機排程", "檢查括號對稱性", "CPU 行程排班", "廣度優先搜尋"], a: 1, h: "左括號 Push，右括號 Pop 檢查匹配。" },
        { q: "若 Stack 狀態為 [10, 20, 30] (30 在頂端)，執行 Top() 回傳？", o: ["10", "20", "30", "3"], a: 2, h: "Top 僅查看頂端元素，不刪除。" },

        // --- 3. 佇列 (Queue) 原理與實作 (Q31-Q45) ---
        { q: "佇列 (Queue) 的存取特性是？", o: ["LIFO", "FIFO (先進先出)", "Random", "Priority"], a: 1, h: "First In, First Out。" },
        { q: "佇列中加入資料的一端稱為？", o: ["Front (前)", "Rear (後)", "Top", "Bottom"], a: 1, h: "從後面排隊 (Rear)。" },
        { q: "佇列中取出資料的一端稱為？", o: ["Front (前)", "Rear (後)", "Top", "Bottom"], a: 0, h: "從前面離開 (Front)。" },
        { q: "環狀佇列 (Circular Queue) 主要是為了解決什麼問題？", o: ["存取速度慢", "假溢位 (False Overflow) / 空間浪費", "程式太複雜", "指標遺失"], a: 1, h: "避免 Front 前面的空間無法重複利用。" },
        { q: "在環狀佇列中 (大小為 N)，Rear 往下一個位置移動的公式為？", o: ["rear++", "rear = rear + 1", "rear = (rear + 1) % N", "rear = rear % N"], a: 2, h: "利用餘數運算繞回開頭。" },
        { q: "為了區分環狀佇列的「空」與「滿」，通常會怎麼做？", o: ["使用一個計數器", "犧牲一個記憶體空間不存資料", "設定 flag", "以上皆可"], a: 1, h: "最常見做法是犧牲一個空間，讓 rear+1 == front 代表滿。" },
        { q: "若環狀佇列大小為 5，front=0, rear=4，執行 enqueue 會？", o: ["成功", "失敗 (Queue Full)", "覆蓋舊資料", "擴充陣列"], a: 1, h: "(4+1)%5 == 0 == front，判定為滿 [cite: 4530] (註：假設犧牲一格)。" },
        { q: "若環狀佇列大小為 5，front=3, rear=3，代表？", o: ["Queue Full", "Queue Empty", "有一個資料", "資料錯誤"], a: 1, h: "Front == Rear 代表空。" },
        { q: "若環狀佇列 front=4, size=5，執行 dequeue 後 front 變為？", o: ["5", "0", "1", "-1"], a: 1, h: "(4+1)%5 = 0。" },
        { q: "佇列常應用於下列何者？", o: ["函式呼叫", "復原 (Undo) 功能", "印表機緩衝區 (Buffer)", "括號匹配"], a: 2, h: "先送印的檔案先列印 (FIFO)。" },
        { q: "若依序 Enqueue(1), Enqueue(2), Dequeue(), Enqueue(3)，最後佇列內容？", o: ["1, 2", "2, 3", "1, 3", "3, 2"], a: 1, h: "進1, 進2 (Q:1,2), 出1 (Q:2), 進3 (Q:2,3)。" },
        { q: "雙尾佇列 (Deque) 的特性是？", o: ["只能兩端進，中間出", "兩端皆可進出", "只能中間進出", "FIFO + LIFO"], a: 1, h: "Double-ended queue。" },
        { q: "使用 Linked List 實作 Queue，Enqueue 應操作在？", o: ["Head", "Tail", "Head 或 Tail 皆可", "隨機"], a: 1, h: "通常 Tail 加入，Head 取出 (或反之，需維護兩個指標)。" },
        { q: "優先權佇列 (Priority Queue) 的出列順序取決於？", o: ["加入時間", "優先權高低", "隨機", "記憶體位址"], a: 1, h: "VIP 先出列。" },
        { q: "在環狀佇列中，計算元素個數的公式為 (N為大小)？", o: "rear - front", o: ["rear - front", "(rear - front + N) % N", "rear + front", "(rear + front) % N"], a: 1, h: "考慮 rear 小於 front 的跨圈情況。" },

        // --- 4. 運算式與應用 (Q46-Q60) ---
        { q: "中序運算式 A + B 轉為後序是？", o: ["+ A B", "A B +", "A + B", "B A +"], a: 1, h: "運算子在運算元後面。" },
        { q: "中序運算式 A * (B + C) 轉為後序是？", o: ["A B C + *", "A B C * +", "A * B + C", "+ * A B C"], a: 0, h: "括號內先做：B C +，再乘 A：A (BC+) *。" },
        { q: "將後序式 3 4 + 5 * 計算結果為？", o: ["35", "23", "19", "17"], a: 0, h: "3+4=7, 7*5=35。" },
        { q: "編譯器通常將中序轉為後序或前序，主要原因是？", o: ["節省空間", "消除括號並由電腦易於計算", "提高精確度", "加密程式碼"], a: 1, h: "後序式不需要括號且無優先權問題。" },
        { q: "前序運算式 + A B 等同於中序的？", o: ["A + B", "B + A", "A B +", "A + + B"], a: 0, h: "運算子在前面。" },
        { q: "運算子 `^` (次方) 通常具有什麼結合性？", o: ["左結合 (由左而右)", "右結合 (由右而左)", "無結合性", "隨機"], a: 1, h: "2^3^2 通常指 2^(3^2) 。" },
        { q: "運算子 `+`, `-`, `*`, `/` 通常具有什麼結合性？", o: ["左結合", "右結合", "無結合性", "雙向"], a: 0, h: "由左而右運算。" },
        { q: "在中序轉後序的演算法中，使用哪種資料結構來暫存運算子？", o: ["Queue", "Stack", "Array", "Tree"], a: 1, h: "遇到運算子先 Push，遇到優先權較低的才 Pop。" },
        { q: "稀疏矩陣 (Sparse Matrix) 若用陣列儲存會浪費空間，可用什麼改善？", o: ["Stack", "Queue", "Linked List", "Binary Tree"], a: 2, h: "使用十字鏈結串列 (Orthogonal Linked List)。" },
        { q: "多項式 $3x^3 + 4x^1$ 使用陣列表示 (由高次到低次)，係數為？", o: ["3, 4", "3, 0, 4, 0", "3, 4, 0, 0", "0, 4, 0, 3"], a: 1, h: "x^3, x^2, x^1, x^0 -> 3, 0, 4, 0。" },
        { q: "若用 Linked List 表示多項式，每個節點通常包含？", o: ["係數", "指數", "Next 指標", "以上皆是"], a: 3, h: "Coef, Exp, Next。" },
        { q: "在迷宮老鼠 (Rat in a Maze) 問題中，若要走回頭路 (Backtracking)，通常使用？", o: ["Stack", "Queue", "Array", "Graph"], a: 0, h: "堆疊紀錄路徑，撞牆時 Pop 回上一格。" },
        { q: "下列何者不是線性資料結構？", o: ["Stack", "Queue", "Linked List", "Tree"], a: 3, h: "Tree 是階層式 (非線性) 結構。" },
        { q: "在 C 語言中，若 malloc 無法配置記憶體，會回傳？", o: ["-1", "0", "NULL", "Error"], a: 2, h: "NULL 指標。" },
        { q: "雙向鏈結串列刪除節點時，若不小心順序錯誤，容易造成？", o: ["記憶體洩漏 (Memory Leak)", "斷鍊 (Broken Link)", "資料錯誤", "以上皆是"], a: 3, h: "指標遺失會導致後續節點無法存取。" }
    ],

    // === 第四章：樹 (請擴充至30題) ===
    // === 第四章：樹 (Trees) (共 60 題) ===
    ch4: [
        // --- 1. 樹的基本定義與術語 (Q1-Q15) ---
        { q: "在樹狀結構中，沒有父節點 (Parent) 的節點稱為？", o: ["Leaf (葉)", "Root (根)", "Child (子)", "Sibling (兄弟)"], a: 1, h: "樹的最頂端節點 [cite: 4652]。" },
        { q: "沒有子節點 (Children) 的節點稱為？", o: ["Root", "Non-terminal", "Leaf (Terminal)", "Degree"], a: 2, h: "又稱為終點節點 [cite: 4660]。" },
        { q: "一個節點擁有的子樹 (或子節點) 個數稱為該節點的？", o: ["Level (階度)", "Height (高度)", "Degree (分支度)", "Order (次序)"], a: 2, h: "Degree 是子節點數量 。" },
        { q: "樹中所有節點的「最大階度 (Level)」稱為該樹的？", o: ["Degree", "Width", "Height (Depth)", "Size"], a: 2, h: "樹的高度或深度 。" },
        { q: "若節點 A 是節點 B 的父節點，則 B 是 A 的？", o: ["Parent", "Child", "Sibling", "Ancestor"], a: 1, h: "相對關係 。" },
        { q: "擁有相同父節點的節點之間互稱為？", o: ["Cousins", "Siblings (兄弟)", "Uncles", "Neighbors"], a: 1, h: "同一個父親的孩子 [cite: 4687]。" },
        { q: "若從節點 X 到節點 Y 有一條路徑，則 X 是 Y 的？", o: ["Descendant (子孫)", "Ancestor (祖先)", "Sibling", "Leaf"], a: 1, h: "X 在 Y 的上面 。" },
        { q: "非終點節點 (Non-terminal Node) 是指？", o: ["沒有子節點的節點", "有子節點的節點", "Root", "Leaf"], a: 1, h: "Degree > 0 的節點 [cite: 4688]。" },
        { q: "由 n >= 0 個互斥的樹 (Disjoint Trees) 所組成的集合稱為？", o: ["Binary Tree", "Forest (樹林)", "Graph", "Heap"], a: 1, h: "多棵樹的集合 。" },
        { q: "樹根 (Root) 的階度 (Level) 通常定義為？", o: ["0", "1", "2", "-1"], a: 1, h: "Root level 為 1，往下遞增 [cite: 4663]。" },
        { q: "一棵樹的 Degree (分支度) 定義為？", o: ["樹根的 Degree", "所有節點 Degree 的總和", "樹中所有節點 Degree 的最大值", "葉節點的數量"], a: 2, h: "整棵樹看最大的那個節點 [cite: 834]。" },
        { q: "若節點 A 在 Level 2，其子節點 B 在 Level 3，則 A 是 B 的？", o: ["Ancestor", "Descendant", "Parent", "Child"], a: 2, h: "直系上一層是 Parent。" },
        { q: "下列關於樹的敘述何者錯誤？", o: ["樹可以沒有節點 (空樹)", "樹根只有一個", "樹中不能有迴圈 (Cycle)", "子樹之間必須互斥"], a: 0, h: "樹定義為一個以上節點 (不能為空) [cite: 4651]。註：二元樹可以為空，但一般樹定義通常 n>=1。" },
        { q: "在樹狀結構中，除了 Root 以外，每個節點有幾個父節點？", o: ["0", "1", "2", "不一定"], a: 1, h: "每個節點只有一個 Parent (除了 Root)。" },
        { q: "若一棵樹有 n 個節點，則它有幾條邊 (Edges)？", o: ["n", "n-1", "n+1", "n^2"], a: 1, h: "除了 Root，每個節點都有一條線連向父節點。" },

        // --- 2. 二元樹 (Binary Tree) 性質與定理 (Q16-Q30) ---
        { q: "二元樹每個節點的分支度 (Degree) 最多為？", o: ["1", "2", "3", "無限"], a: 1, h: "最多兩個子節點 [cite: 4695]。" },
        { q: "關於二元樹與一般樹的差異，下列何者正確？", o: ["二元樹不能為空", "二元樹子樹沒有左右之分", "二元樹子樹有嚴格左右之分", "二元樹 Degree 可以大於 2"], a: 2, h: "左子樹與右子樹是不同的 。" },
        { q: "二元樹的第 i 層 (Level i) 最多有幾個節點？", o: ["2^(i-1)", "2^i", "2i", "i^2"], a: 0, h: "定理一 [cite: 4706]。" },
        { q: "高度 (Height) 為 k 的二元樹，最多共有幾個節點？", o: ["2^k", "2^k - 1", "2^(k-1)", "k^2"], a: 1, h: "定理二 。" },
        { q: "高度為 k 的二元樹，最少有幾個節點？(假設沒有空層)", o: ["k", "2k", "k-1", "2^k"], a: 0, h: "每一層只有一個節點 (歪斜樹)。" },
        { q: "若非空二元樹有 n0 個葉節點 (Leaf)，n2 個 Degree=2 的節點，則？", o: ["n0 = n2", "n0 = n2 + 1", "n2 = n0 + 1", "n0 = 2 * n2"], a: 1, h: "定理三 。" },
        { q: "若一棵二元樹有 10 個 Degree=2 的節點，請問它有幾個 Leaf？", o: ["9", "10", "11", "12"], a: 2, h: "10 + 1 = 11 。" },
        { q: "若一棵二元樹有 20 個 Leaf，則 Degree=2 的節點有幾個？", o: ["19", "20", "21", "18"], a: 0, h: "n2 = n0 - 1 = 19。" },
        { q: "滿枝二元樹 (Full Binary Tree) 的定義是？", o: ["所有節點都有兩個子節點", "高度 k 且有 2^k - 1 個節點", "沒有 Degree=1 的節點", "所有葉節點在同一層"], a: 1, h: "節點數達到最大值 。" },
        { q: "完整二元樹 (Complete Binary Tree) 的特點是？", o: ["一定是滿枝二元樹", "節點編號順序與滿枝二元樹一致", "只有右子樹", "高度無限"], a: 1, h: "由上而下，由左而右填滿 。" },
        { q: "左斜樹 (Left Skewed Tree) 是指？", o: ["所有節點只有右子節點", "所有節點只有左子節點", "樹根在左邊", "葉節點在右邊"], a: 1, h: "一直往左長 。" },
        { q: "歪斜樹 (Skewed Tree) 的空間利用率？", o: ["很好", "普通", "最差 (浪費空間)", "不一定"], a: 2, h: "若用陣列儲存，會浪費大量空間。" },
        { q: "具有 n 個節點的完整二元樹，其高度 k 約為？", o: ["n", "n/2", "log2(n+1)", "n^2"], a: 2, h: "k = ceiling(log2(n+1)) 。" },
        { q: "二元樹可以為空集合嗎？", o: ["可以", "不行", "只有滿枝可以", "只有完整可以"], a: 0, h: "二元樹定義允許為空 。" },
        { q: "若 A 的左子樹不為空，右子樹為空；B 的左子樹為空，右子樹不為空 (內容相同)，則 A 與 B？", o: ["相同", "不相同", "視情況而定", "無法比較"], a: 1, h: "二元樹左右有別 。" },

        // --- 3. 二元樹的表示與實作 (Q31-Q40) ---
        { q: "使用陣列 (Array) 表示二元樹，若節點索引為 i (從 1 開始)，其左子節點索引為？", o: ["2i", "2i+1", "i/2", "i+1"], a: 0, h: "左子 2i，右子 2i+1 。" },
        { q: "使用陣列表示二元樹，若節點索引為 i (從 1 開始)，其右子節點索引為？", o: ["2i", "2i+1", "i/2", "i-1"], a: 1, h: "右子 2i+1 [cite: 751]。" },
        { q: "使用陣列表示二元樹，若節點索引為 i (從 1 開始)，其父節點索引為？", o: ["2i", "2i+1", "floor(i/2)", "i-1"], a: 2, h: "i/2 取整數 。" },
        { q: "若用陣列儲存歪斜樹 (Skewed Tree)，主要缺點是？", o: ["存取慢", "浪費記憶體空間", "程式難寫", "無法實作"], a: 1, h: "會有大量空洞。" },
        { q: "鏈結串列 (Linked List) 表示二元樹，每個節點通常包含幾個欄位？", o: ["1 (Data)", "2 (Data, Link)", "3 (Data, LChild, RChild)", "4"], a: 2, h: "資料 + 左指標 + 右指標 。" },
        { q: "若一棵 n 個節點的二元樹用鏈結串列表示，會有多少個 NULL 指標 (空鏈結)？", o: ["n", "n-1", "n+1", "2n"], a: 2, h: "總指標 2n，扣掉用掉的 n-1 (邊)，剩 n+1 。" },
        { q: "C 語言中，定義二元樹節點的 struct 通常包含？", o: ["int data; node *next;", "int data; node *left; node *right;", "int data;", "node *link;"], a: 1, h: "需要左右兩個指標。" },
        { q: "陣列表示法最適合哪種二元樹？", o: ["歪斜樹", "一般二元樹", "完整二元樹 (Complete BT)", "所有二元樹"], a: 2, h: "因為中間不會有空洞，最節省空間。" },
        { q: "在鏈結串列表示法中，Leaf 節點的特徵是？", o: ["left!=NULL, right!=NULL", "left==NULL, right==NULL", "只有 left==NULL", "只有 right==NULL"], a: 1, h: "左右指標皆為空。" },
        { q: "若節點索引為 1 是 Root，則索引 5 的父節點索引為？", o: ["1", "2", "3", "4"], a: 1, h: "5/2 = 2.5 -> 取 2。" },

        // --- 4. 二元樹的走訪 (Traversal) (Q41-Q50) ---
        { q: "前序走訪 (Preorder) 的順序是？", o: ["左 -> 根 -> 右", "根 -> 左 -> 右", "左 -> 右 -> 根", "根 -> 右 -> 左"], a: 1, h: "D L R [cite: 783]。" },
        { q: "中序走訪 (Inorder) 的順序是？", o: ["左 -> 根 -> 右", "根 -> 左 -> 右", "左 -> 右 -> 根", "右 -> 根 -> 左"], a: 0, h: "L D R [cite: 814]。" },
        { q: "後序走訪 (Postorder) 的順序是？", o: ["左 -> 根 -> 右", "根 -> 左 -> 右", "左 -> 右 -> 根", "右 -> 左 -> 根"], a: 2, h: "L R D [cite: 781]。" },
        { q: "若二元樹為運算式樹 (Expression Tree)，哪種走訪可得到「後序運算式」？", o: ["Preorder", "Inorder", "Postorder", "Level-order"], a: 2, h: "Postorder 對應 Postfix。" },
        { q: "若二元樹為運算式樹，哪種走訪可得到「中序運算式」？", o: ["Preorder", "Inorder", "Postorder", "Level-order"], a: 1, h: "Inorder 對應 Infix (需加括號)。" },
        { q: "已知前序為 ABC，中序為 CBA，則後序為？", o: ["ABC", "CBA", "BCA", "CAB"], a: 1, h: "Root是A。中序CBA -> C,B在左。前序AB -> B是A的左子。B的中序是CB -> C是B的左子。樹: A->Left(B->Left(C))。後序: C B A。" },
        { q: "若要複製一棵二元樹，通常使用哪種走訪？", o: ["Preorder", "Inorder", "Postorder", "都可以"], a: 2, h: "Postorder 適合，先複製子樹再複製根 (或 Preorder 也可以，視實作而定)。" },
        { q: "若要刪除整棵二元樹 (釋放記憶體)，應使用哪種走訪？", o: ["Preorder", "Inorder", "Postorder", "Level-order"], a: 2, h: "必須先刪除左右子樹，才能刪除父節點 (Postorder)。" },
        { q: "層序走訪 (Level-order Traversal) 使用哪種資料結構輔助？", o: ["Stack", "Queue", "Array", "Linked List"], a: 1, h: "類似 BFS，使用 Queue。" },
        { q: "非遞迴 (Non-recursive) 的中序走訪通常使用什麼輔助？", o: ["Queue", "Stack", "Array", "Pointer"], a: 1, h: "模擬遞迴，使用 Stack。" },

        // --- 5. 二元搜尋樹 (BST) 與 Heap (Q51-Q60) ---
        { q: "二元搜尋樹 (Binary Search Tree, BST) 的特性是？", o: ["左 < 根 < 右", "左 > 根 > 右", "無序", "完全平衡"], a: 0, h: "左子樹所有值小於根，右子樹所有值大於根 。" },
        { q: "在 BST 中進行搜尋，平均時間複雜度為？", o: ["O(1)", "O(n)", "O(log n)", "O(n^2)"], a: 2, h: "類似二分搜尋。" },
        { q: "對 BST 進行哪種走訪，可以得到「排序後」的資料序列？", o: ["Preorder", "Inorder", "Postorder", "Level-order"], a: 1, h: "中序走訪 (左<根<右) 會由小到大輸出。" },
        { q: "Max Heap (最大堆積) 的特性是？", o: ["父節點 >= 子節點", "父節點 <= 子節點", "左子 >= 右子", "完全有序"], a: 0, h: "根節點是最大值 [cite: 1083]。" },
        { q: "Min Heap (最小堆積) 的根節點是？", o: ["最大值", "最小值", "中間值", "隨機值"], a: 1, h: "父 <= 子，故根最小。" },
        { q: "Heap 通常使用什麼方式儲存？", o: ["Linked List", "Array", "Stack", "Queue"], a: 1, h: "因為 Heap 是 Complete Binary Tree，用 Array 最省空間。" },
        { q: "在 Max Heap 中插入新元素，需要進行什麼操作？", o: ["Shift Down", "Bubble Up (Reheap Up)", "Rotate", "Swap Root"], a: 1, h: "加在最後，然後往上浮升調整。" },
        { q: "從 Max Heap 刪除元素 (通常刪 Root)，需要進行？", o: ["Bubble Up", "Bubble Down (Reheap Down)", "Rotate", "Do nothing"], a: 1, h: "拿最後一個補 Root，然後往下沉降調整。" },
        { q: "建立一個 Heap 的時間複雜度為？", o: ["O(n)", "O(n log n)", "O(1)", "O(n^2)"], a: 0, h: "使用 Linear Time Build Heap 演算法為 O(n)。" },
        { q: "BST 最壞情況 (歪斜樹) 的搜尋時間複雜度為？", o: ["O(1)", "O(log n)", "O(n)", "O(n^2)"], a: 2, h: "退化成 Linked List，需走訪所有節點。" }
    ],

    // === 第五章：圖 (請擴充至30題) ===
    // === 第五章：圖形結構 (Graphs) (共 60 題) ===
    ch5: [
        // --- 1. 圖的基本定義與術語 (Q1-Q15) ---
        { q: "圖形 G = (V, E) 中，V 與 E 分別代表？", o: ["數值，指標", "頂點 (Vertex)，邊 (Edge)", "向量，指數", "體積，邊長"], a: 1, h: "Vertex (頂點) 與 Edge (邊)。" },
        { q: "無向圖 (Undirected Graph) 的邊 (u, v) 與 (v, u) 是？", o: ["相同的", "不同的", "互為倒數", "無法比較"], a: 0, h: "無向圖的邊沒有方向性 。" },
        { q: "有向圖 (Directed Graph) 的邊 <u, v> 代表方向是？", o: ["u 指向 v", "v 指向 u", "雙向", "無方向"], a: 0, h: "箭頭由 u 出發指向 v。" },
        { q: "在無向圖中，連接頂點 V 的邊數稱為 V 的？", o: ["高度", "深度", "分支度 (Degree)", "權重"], a: 2, h: "Degree 代表連接的邊數 [cite: 2865]。" },
        { q: "在有向圖中，指向頂點 V 的邊數稱為？", o: ["Out-degree (外分支度)", "In-degree (內分支度)", "Total-degree", "Height"], a: 1, h: "箭頭進入為 In-degree 。" },
        { q: "在有向圖中，由頂點 V 指出去的邊數稱為？", o: ["Out-degree (外分支度)", "In-degree (內分支度)", "Degree", "Weight"], a: 0, h: "箭頭出去為 Out-degree 。" },
        { q: "一個具有 n 個頂點的「完全圖 (Complete Graph)」(無向)，其邊數為？", o: ["n", "n^2", "n(n-1)/2", "2n"], a: 2, h: "任兩點皆相連：C(n, 2)。" },
        { q: "若圖形中任意兩點之間都存在路徑，則稱此圖為？", o: ["連通圖 (Connected Graph)", "完整圖", "樹", "森林"], a: 0, h: "沒有孤立的點或區塊。" },
        { q: "包含圖 G 中所有頂點，但邊數最少的連通子圖稱為？", o: ["子圖", "生成樹 (Spanning Tree)", "完全圖", "補圖"], a: 1, h: "生成樹包含所有頂點且無迴圈 。" },
        { q: "一個具有 n 個頂點的生成樹 (Spanning Tree)，恰好有幾條邊？", o: ["n", "n-1", "n+1", "n/2"], a: 1, h: "樹的特性：邊數 = 頂點數 - 1。" },
        { q: "加權圖 (Weighted Graph) 的邊上帶有什麼？", o: ["方向", "權重 (Weight)", "顏色", "標籤"], a: 1, h: "數值，代表成本或距離。" },
        { q: "若有向圖中存在路徑 v1 -> v2 -> ... -> vn -> v1，則稱此路徑為？", o: ["最短路徑", "簡單路徑", "迴圈 (Cycle)", "樹"], a: 2, h: "起點與終點相同。" },
        { q: "無向圖中，所有頂點的 Degree 總和等於邊數的幾倍？", o: ["1 倍", "2 倍", "3 倍", "0.5 倍"], a: 1, h: "每條邊連線兩個頂點，故貢獻 2 個 Degree。" },
        { q: "AOV Network (Activity On Vertex) 通常用來表示？", o: ["電路圖", "工程計畫與先後順序", "地圖導航", "家族關係"], a: 1, h: "表示事件的優先順序 。" },
        { q: "DAG 是指什麼？", o: ["有向無環圖 (Directed Acyclic Graph)", "雙向圖", "動態陣列圖", "深度優先圖"], a: 0, h: "有方向性且沒有迴圈的圖。" },

        // --- 2. 圖的表示法 (Q16-Q25) ---
        { q: "相鄰矩陣 (Adjacency Matrix) 使用什麼資料結構儲存圖？", o: ["一維陣列", "二維陣列", "鏈結串列", "堆疊"], a: 1, h: "A[n][n] [cite: 2905-2906]。" },
        { q: "相鄰串列 (Adjacency List) 使用什麼資料結構？", o: ["僅陣列", "僅指標", "陣列結合鏈結串列", "樹"], a: 2, h: "陣列存頭，鏈結串列存鄰居 [cite: 2918-2919]。" },
        { q: "若圖有 n 個頂點，相鄰矩陣的空間複雜度為？", o: ["O(n)", "O(e)", "O(n^2)", "O(n+e)"], a: 2, h: "需要 n*n 的空間。" },
        { q: "對於「稀疏圖 (Sparse Graph)」(邊很少)，哪種表示法較節省空間？", o: ["相鄰矩陣", "相鄰串列", "兩者一樣", "無法判斷"], a: 1, h: "相鄰串列只儲存存在的邊。" },
        { q: "對於「稠密圖 (Dense Graph)」(邊很多)，哪種表示法較適合？", o: ["相鄰矩陣", "相鄰串列", "堆疊", "佇列"], a: 0, h: "相鄰矩陣存取快，且空間利用率高。" },
        { q: "在相鄰矩陣 A[i][j] 中，若值為 1 代表？", o: ["i 和 j 不相連", "i 和 j 有邊相連", "i 和 j 是同一個點", "i > j"], a: 1, h: "1 代表有邊，0 代表無邊。" },
        { q: "無向圖的相鄰矩陣具有什麼特性？", o: ["對稱於主對角線", "全為 0", "全為 1", "上三角為 0"], a: 0, h: "A[i][j] == A[j][i]。" },
        { q: "在相鄰串列中，計算頂點 V 的 Out-degree 需要？", o: ["O(1)", "計算該串列的節點數", "掃描整個陣列", "無法計算"], a: 1, h: "串列長度即為 Out-degree。" },
        { q: "在相鄰矩陣中，判斷任意兩點 (u, v) 是否有邊的時間複雜度？", o: ["O(1)", "O(n)", "O(e)", "O(n^2)"], a: 0, h: "直接查 A[u][v]。" },
        { q: "具有 n 個頂點 e 條邊的圖，相鄰串列的空間複雜度約為？", o: ["O(n)", "O(e)", "O(n + e)", "O(n^2)"], a: 2, h: "頂點表頭 n + 邊節點 e (無向圖為 2e)。" },

        // --- 3. 圖的走訪 (Traversal) (Q26-Q35) ---
        { q: "深度優先搜尋 (DFS) 使用哪種資料結構輔助？", o: ["Queue", "Stack", "Array", "Tree"], a: 1, h: "堆疊 (Stack) 或遞迴 。" },
        { q: "廣度優先搜尋 (BFS) 使用哪種資料結構輔助？", o: ["Queue", "Stack", "Array", "Graph"], a: 0, h: "佇列 (Queue) 。" },
        { q: "DFS 的搜尋策略類似於？", o: ["地毯式搜索", "走迷宮 (一條路走到底)", "隨機搜索", "最短路徑"], a: 1, h: "深入到底再回溯 (Backtracking)。" },
        { q: "BFS 的搜尋策略類似於？", o: ["走迷宮", "同心圓擴散 (層層推進)", "隨機跳躍", "最長路徑"], a: 1, h: "先訪問鄰居，再訪問鄰居的鄰居。" },
        { q: "若要尋找無權重圖的最短路徑，應使用？", o: ["DFS", "BFS", "Prim", "Kruskal"], a: 1, h: "BFS 保證先找到距離為 1, 2... 的節點。" },
        { q: "DFS 走訪過程中產生的樹稱為？", o: ["最小生成樹", "DFS Spanning Tree", "二元搜尋樹", "AVL Tree"], a: 1, h: "DFS 生成樹。" },
        { q: "在 AOV Network 中，拓樸排序 (Topological Sort) 適用於哪種圖？", o: ["有向有環圖", "有向無環圖 (DAG)", "無向圖", "完全圖"], a: 1, h: "必須無環才能排序。" },
        { q: "拓樸排序演算法的第一步是？", o: ["找 Out-degree = 0 的點", "找 In-degree = 0 的點", "隨機選點", "找權重最小的邊"], a: 1, h: "沒有前置作業的點先執行 。" },
        { q: "若拓樸排序過程中，找不到 In-degree = 0 的點，代表？", o: ["圖中有迴圈 (Cycle)", "圖是空的", "排序完成", "圖不連通"], a: 0, h: "互為前置條件，無法執行。" },
        { q: "使用相鄰串列進行 DFS 的時間複雜度？", o: ["O(n)", "O(n^2)", "O(n + e)", "O(e)"], a: 2, h: "訪問所有點與邊。" },

        // --- 4. 最小生成樹 (MST) (Q36-Q45) ---
        { q: "最小生成樹 (MST) 是指？", o: ["邊數最少的樹", "權重總和最小的生成樹", "高度最小的樹", "節點最少的樹"], a: 1, h: "Cost 最小。" },
        { q: "Prim's Algorithm 的策略是？", o: ["以邊為中心", "以頂點為中心 (Grow from vertex)", "隨機選邊", "刪除最大邊"], a: 1, h: "從一個點開始，慢慢長大 [cite: 2961]。" },
        { q: "Kruskal's Algorithm 的策略是？", o: ["以邊為中心 (Greedy on edges)", "以頂點為中心", "隨機選點", "刪除迴圈"], a: 0, h: "從小到大選邊，不造成迴圈就加入。" },
        { q: "在 Kruskal's Algorithm 中，如何判斷加入一條邊是否會形成迴圈？", o: ["DFS", "BFS", "Union-Find (Disjoint Set)", "Stack"], a: 2, h: "檢查兩點是否已在同一個集合中。" },
        { q: "Prim's Algorithm 適合哪種圖？", o: ["稀疏圖", "稠密圖 (Dense Graph)", "樹", "無向圖"], a: 1, h: "邊多時，Prim (O(n^2)) 優於 Kruskal (O(e log e))。" },
        { q: "MST 中若有 n 個頂點，則必有幾條邊？", o: ["n", "n-1", "n+1", "n^2"], a: 1, h: "生成樹特性。" },
        { q: "MST 一定是唯一的嗎？", o: ["是", "否", "視演算法而定", "只有 Prim 是唯一"], a: 1, h: "若有多條邊權重相同，MST 可能不只一種。" },
        { q: "Prim's Algorithm 的時間複雜度 (使用陣列) 為？", o: ["O(n)", "O(n^2)", "O(e log e)", "O(n log n)"], a: 1, h: "適合稠密圖。" },
        { q: "在執行 Kruskal 演算法前，必須對邊進行什麼操作？", o: ["隨機排列", "依權重由小到大排序", "依權重由大到小排序", "反轉"], a: 1, h: "Greedy 策略。" },
        { q: "MST 演算法適用於有向圖嗎？", o: ["適用", "不適用", "需修改定義", "只適用 DAG"], a: 1, h: "通常定義在加權連通無向圖。" },

        // --- 5. 最短路徑與應用 (Q46-Q60) ---
        { q: "Dijkstra 演算法用於解決什麼問題？", o: ["最小生成樹", "單一來源最短路徑", "所有配對最短路徑", "拓樸排序"], a: 1, h: "Single Source Shortest Path [cite: 3004]。" },
        { q: "Dijkstra 演算法使用哪種策略？", o: ["Divide and Conquer", "Greedy (貪婪)", "Dynamic Programming", "Backtracking"], a: 1, h: "每次選目前距離最近的點。" },
        { q: "Dijkstra 演算法不適用於？", o: ["有向圖", "無向圖", "負權重邊的圖", "有環圖"], a: 2, h: "負權重會導致貪婪策略失效。" },
        { q: "若圖中有負權重邊，應使用哪種最短路徑演算法？", o: ["Prim", "Kruskal", "Dijkstra", "Bellman-Ford"], a: 3, h: "Bellman-Ford 可處理負邊。" },
        { q: "Floyd-Warshall 演算法用於解決？", o: ["單一來源最短路徑", "所有頂點對 (All-Pairs) 最短路徑", "MST", "拓樸排序"], a: 1, h: "多源最短路徑。" },
        { q: "AOE Network (Activity On Edge) 的關鍵路徑 (Critical Path) 是指？", o: ["最短的路徑", "最長的路徑", "中間的路徑", "隨機路徑"], a: 1, h: "決定專案最早完成時間的路徑 (最長路徑) 。" },
        { q: "在 AOE 網路上，若某活動延誤，是否一定會延誤整個專案？", o: ["一定會", "一定不會", "若該活動在關鍵路徑上則會", "視天氣而定"], a: 2, h: "只有關鍵路徑上的活動沒有緩衝時間。" },
        { q: "尤拉迴路 (Eulerian Circuit) 的條件是？", o: ["所有頂點度數皆為偶數", "所有頂點度數皆為奇數", "有起點和終點", "沒有限制"], a: 0, h: "進出次數必須相等 。" },
        { q: "漢米爾頓迴路 (Hamiltonian Cycle) 是指？", o: ["經過每條邊一次", "經過每個頂點一次且回到起點", "經過重心", "最短迴路"], a: 1, h: "走訪所有頂點。" },
        { q: "計算最短路徑時，Relaxation (鬆弛) 操作是指？", o: ["休息一下", "若發現更短路徑則更新距離", "刪除頂點", "增加權重"], a: 1, h: "更新 dist[v] = min(dist[v], dist[u] + w)。" },
        { q: "在 AOV 網路中，若存在 A -> B，代表？", o: ["A 必須在 B 之前完成", "B 必須在 A 之前完成", "A 和 B 可同時進行", "A 和 B 互斥"], a: 0, h: "A 是 B 的前置作業。" },
        { q: "圖形著色問題 (Graph Coloring) 中，相鄰頂點必須？", o: ["同色", "不同色", "無限制", "黑色"], a: 1, h: "避免混淆。" },
        { q: "網路流 (Network Flow) 問題中，Source 和 Sink 分別代表？", o: ["起點與終點", "最大與最小", "左邊與右邊", "上與下"], a: 0, h: "流的源頭與匯流點。" },
        { q: "轉置圖 (Transpose Graph) 是將有向圖的？", o: ["頂點刪除", "邊的方向反轉", "權重加倍", "變成無向圖"], a: 1, h: "箭頭全部反過來。" },
        { q: "下列何者是圖形結構的應用？", o: ["Google Maps 導航", "電路板佈線", "社交網路分析", "以上皆是"], a: 3, h: "圖形應用極廣。" }
    ],
};

// === 總複習題庫 (將所有章節合併) ===
questionBank.final = [
    ...questionBank.ch1,
    ...questionBank.ch2,
    ...questionBank.ch3,
    ...questionBank.ch4,
    ...questionBank.ch5
];

// --- 測驗狀態變數 ---
let currentQuiz = []; // 存放隨機抽出的 10 題
let currentQIndex = 0;
let score = 0;
let timerInterval;
let seconds = 0;
let currentChapterTitle = ""; // 紀錄當前章節名稱
// ... 其他變數 ...
let userHistory = []; // ★ 新增：用來紀錄每一題使用者的作答狀況
// --- 1. 開始測驗 (核心邏輯) ---
function startQuiz(chapterKey) {
    // 設定標題
    const titles = {
        'ch1': 'Chapter 1: 演算法 & 指標',
        'ch2': 'Chapter 2: 陣列 (Arrays)',
        'ch3': 'Chapter 3: 堆疊 / 佇列 / 鏈結',
        'ch4': 'Chapter 4: 樹 (Trees)',
        'ch5': 'Chapter 5: 圖 (Graphs)',
        'final': '期末總複習 (Final Review)'
    };
    currentChapterTitle = titles[chapterKey];
    document.getElementById('quiz-title').innerText = currentChapterTitle;

    // 核心：從題庫中隨機抽出 10 題
    const sourceQuestions = questionBank[chapterKey];
    // 複製陣列以免修改原題庫，並執行洗牌
    currentQuiz = shuffleArray([...sourceQuestions]).slice(0, 10);

    // 重置變數
    currentQIndex = 0;
    score = 0;
    seconds = 0;
    userHistory = []; // ★ 新增：重置紀錄
    document.getElementById('correct-num').innerText = '0';
    document.getElementById('wrong-num').innerText = '0';

    // 切換畫面
    showScreen('quiz-screen');
    
    // 開始計時與載入題目
    startTimer();
    loadQuestion();
}

// --- 2. 洗牌演算法 (Fisher-Yates Shuffle) ---
function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}

// --- 3. 載入題目 ---
function loadQuestion() {
    const qData = currentQuiz[currentQIndex];
    
    // 更新進度
    document.getElementById('current-q').innerText = currentQIndex + 1;
    const progressPercent = ((currentQIndex) / 10) * 100; // 總共10題
    document.getElementById('progress-fill').style.width = `${progressPercent}%`;

    // 顯示題目
    document.getElementById('question-text').innerText = qData.q;

    // 生成選項
    const optionsBox = document.getElementById('options-box');
    optionsBox.innerHTML = ''; // 清空

    qData.o.forEach((opt, index) => {
        const btn = document.createElement('button');
        btn.className = 'opt-btn';
        btn.innerText = opt;
        btn.onclick = () => checkAnswer(index, btn, qData.a, qData.h);
        optionsBox.appendChild(btn);
    });
}

// --- 4. 檢查答案 (最終合併版：含防呆、計分、詳解紀錄、錯題儲存) ---
function checkAnswer(userIndex, btnElement, correctIndex, hint) {
    // 1. 鎖定所有按鈕，防止連點
    const allBtns = document.querySelectorAll('.opt-btn');
    allBtns.forEach(btn => btn.disabled = true);

    // 2. 記錄作答歷史 (這是為了最後顯示 "答題詳解" 用的)
    userHistory.push({
        questionIndex: currentQIndex,
        userSelect: userIndex,
        correctSelect: correctIndex,
        isCorrect: (userIndex === correctIndex)
    });

    // 3. 判斷對錯
    if (userIndex === correctIndex) {
        // --- 答對的情況 ---
        btnElement.classList.add('correct');
        // 防止重複加圖標
        if (!btnElement.innerHTML.includes('fa-check')) {
            btnElement.innerHTML += ' <i class="fa-solid fa-check"></i>';
        }
        score += 10; 
    } else {
        // --- 答錯的情況 ---
        btnElement.classList.add('wrong');
        // 防止重複加圖標
        if (!btnElement.innerHTML.includes('fa-xmark')) {
            btnElement.innerHTML += ' <i class="fa-solid fa-xmark"></i>';
        }
        
        // 顯示正確答案 (變綠色)
        const correctBtn = allBtns[correctIndex];
        correctBtn.classList.add('correct');

        // ★★★ 關鍵：儲存錯題到複習中心 (LocalStorage) ★★★
        // 取得當前題目的完整資料
        const currentQ = currentQuiz[currentQIndex]; 
        const wrongData = {
            question: currentQ.q,
            userAns: currentQ.o[userIndex],
            correctAns: currentQ.o[correctIndex],
            hint: currentQ.h
        };

        // 讀取瀏覽器目前的錯題紀錄
        let savedWrongs = JSON.parse(localStorage.getItem('ds_wrong_questions')) || [];
        
        // 避免重複儲存同一題 (檢查題目文字是否完全相同)
        const isExist = savedWrongs.some(w => w.question === wrongData.question);
        
        if (!isExist) {
            savedWrongs.push(wrongData);
            // 存回瀏覽器
            localStorage.setItem('ds_wrong_questions', JSON.stringify(savedWrongs));
        }
        // ★★★ 儲存結束 ★★★
    }

    // 4. 延遲 1.2 秒後跳下一題
    setTimeout(() => {
        currentQIndex++;
        if (currentQIndex < 10) {
            loadQuestion();
        } else {
            endQuiz();
        }
    }, 1200);
}

// --- 5. 結束測驗 ---
function endQuiz() {
    clearInterval(timerInterval);
    showScreen('result-screen');

    // 更新結果數據
    const finalScoreEl = document.getElementById('final-score');
    const correctCount = score / 10;
    const wrongCount = 10 - correctCount;

    finalScoreEl.innerText = score;
    document.getElementById('correct-num').innerText = correctCount;
    document.getElementById('wrong-num').innerText = wrongCount;

    // 動態圓餅圖顏色
    const chart = document.querySelector('.score-chart');
    if (score >= 60) {
        chart.style.background = `conic-gradient(#2ecc71 ${score}%, #eee 0)`;
        document.getElementById('result-msg').innerText = score === 100 ? "太神啦！滿分！" : "恭喜及格！";
        document.getElementById('result-msg').style.color = "#27ae60";
    } else {
        chart.style.background = `conic-gradient(#e74c3c ${score}%, #eee 0)`;
        document.getElementById('result-msg').innerText = "再接再厲！";
        document.getElementById('result-msg').style.color = "#e74c3c";
    }
    // ★ 新增：呼叫生成詳解函式
    renderReview();
}

// ★★★ 新增函式：生成詳解列表 ★★★
function renderReview() {
    const container = document.getElementById('review-container');
    container.innerHTML = ''; // 清空舊內容

    // 遍歷每一題的歷史紀錄
    userHistory.forEach((record, index) => {
        // 從 currentQuiz 取得該題目的完整資料
        const qData = currentQuiz[index];
        
        // 建立 HTML 結構
        const itemDiv = document.createElement('div');
        // 根據對錯加上 class (讓 CSS 變色)
        itemDiv.className = `review-item ${record.isCorrect ? 'correct' : 'wrong'}`;

        const userOptionText = qData.o[record.userSelect];
        const correctOptionText = qData.o[record.correctSelect];

        itemDiv.innerHTML = `
            <div class="review-q">Q${index + 1}: ${qData.q}</div>
            <div class="review-ans user">
                你的答案：${userOptionText} 
                ${record.isCorrect ? '<i class="fa-solid fa-check" style="color:var(--correct)"></i>' : '<i class="fa-solid fa-xmark" style="color:var(--wrong)"></i>'}
            </div>
            ${!record.isCorrect ? `<div class="review-ans correct-ans">正確答案：${correctOptionText}</div>` : ''}
            <div class="review-explain">
                <strong><i class="fa-solid fa-lightbulb"></i> 解析：</strong><br>
                ${qData.h}
            </div>
        `;

        container.appendChild(itemDiv);
    });
}

// --- 6. 計時器 ---
function startTimer() {
    clearInterval(timerInterval);
    seconds = 0;
    const timerEl = document.getElementById('timer');
    timerInterval = setInterval(() => {
        seconds++;
        const mins = Math.floor(seconds / 60).toString().padStart(2, '0');
        const secs = (seconds % 60).toString().padStart(2, '0');
        timerEl.innerText = `${mins}:${secs}`;
    }, 1000);
}

// --- 7. 畫面切換輔助 ---
function showScreen(screenId) {
    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    document.getElementById(screenId).classList.add('active');
}

// 按鈕功能
function goHome() {
    showScreen('menu-screen');
}

function retryQuiz() {
    // 重新開始同一個章節 (會重新抽題)
    // 找出當前章節的 Key (需要反推或是存全域變數)
    // 這裡我們簡化：在 startQuiz 時已經存了 currentChapterTitle，
    // 但我們需要 key。為了方便，我們改寫 startQuiz 讓它存 key。
    
    // 簡單解法：直接 reload 或 重新呼叫 startQuiz
    // 由於我們沒有存 key，這裡用一個全域變數存起來
    if (lastChapterKey) {
        startQuiz(lastChapterKey);
    }
}

let lastChapterKey = 'ch1'; // 預設
// 修改 startQuiz 紀錄 key
const originalStartQuiz = startQuiz;
startQuiz = function(key) {
    lastChapterKey = key;
    originalStartQuiz(key);
}